# 动态传感器

### 总述

Android 平台提供多种传感器，可让您监视设备的运动。

传感器的可能架构因传感器类型而异：

- 重力、线性加速度、旋转矢量、有效运动、计步器和步测器传感器可能基于硬件，也可能基于软件。
- 加速度计传感器和陀螺仪传感器始终基于硬件。



运动传感器在监控设备运动方面（例如倾斜、晃动、旋转或摆动）非常有用。该移动通常是用户直接输入的反映（例如，用户在游戏中驾驶汽车，或在游戏中控制球），但也可能反映设备所处的物理环境（例如，在开车时与您一起移动）。

**表 1.** Android 平台支持的运动传感器。

| 传感器                            | 传感器事件数据          | 说明                                             | 度量单位 |
| :-------------------------------- | :---------------------- | :----------------------------------------------- | :------- |
| `TYPE_ACCELEROMETER`              | `SensorEvent.values[0]` | 沿 x 轴的加速力（包括重力）。                    | 米/秒2   |
|                                   | `SensorEvent.values[1]` | 沿 y 轴的加速力（包括重力）。                    |          |
|                                   | `SensorEvent.values[2]` | 沿 z 轴的加速力（包括重力）。                    |          |
| `TYPE_ACCELEROMETER_UNCALIBRATED` | `SensorEvent.values[0]` | 沿 X 轴测量的加速度，没有任何偏差补偿。          | 米/秒2   |
|                                   | `SensorEvent.values[1]` | 沿 Y 轴测量的加速度，没有任何偏差补偿。          |          |
|                                   | `SensorEvent.values[2]` | 沿 Z 轴测量的加速度，没有任何偏差补偿。          |          |
|                                   | `SensorEvent.values[3]` | 沿 X 轴测量的加速度，并带有估算的偏差补偿。      |          |
|                                   | `SensorEvent.values[4]` | 沿 Y 轴测量的加速度，并带有估算的偏差补偿。      |          |
|                                   | `SensorEvent.values[5]` | 沿 Z 轴测量的加速度，并带有估算的偏差补偿。      |          |
| `TYPE_GRAVITY`                    | `SensorEvent.values[0]` | 沿 x 轴的重力。                                  | 米/秒2   |
|                                   | `SensorEvent.values[1]` | 沿 y 轴的重力。                                  |          |
|                                   | `SensorEvent.values[2]` | 沿 z 轴的重力。                                  |          |
| `TYPE_GYROSCOPE`                  | `SensorEvent.values[0]` | 绕 x 轴的旋转速率。                              | 弧度/秒  |
|                                   | `SensorEvent.values[1]` | 绕 y 轴的旋转速率。                              |          |
|                                   | `SensorEvent.values[2]` | 绕 z 轴的旋转速率。                              |          |
| `TYPE_GYROSCOPE_UNCALIBRATED`     | `SensorEvent.values[0]` | 绕 x 轴的旋转速率（无漂移补偿）。                | 弧度/秒  |
|                                   | `SensorEvent.values[1]` | 绕 y 轴的旋转速率（无漂移补偿）。                |          |
|                                   | `SensorEvent.values[2]` | 绕 z 轴的旋转速率（无漂移补偿）。                |          |
|                                   | `SensorEvent.values[3]` | 绕 x 轴的估算漂移。                              |          |
|                                   | `SensorEvent.values[4]` | 绕 y 轴的估算漂移。                              |          |
|                                   | `SensorEvent.values[5]` | 绕 z 轴的估算漂移。                              |          |
| `TYPE_LINEAR_ACCELERATION`        | `SensorEvent.values[0]` | 沿 x 轴的加速力（不包括重力）。                  | 米/秒2   |
|                                   | `SensorEvent.values[1]` | 沿 y 轴的加速力（不包括重力）。                  |          |
|                                   | `SensorEvent.values[2]` | 沿 z 轴的加速力（不包括重力）。                  |          |
| `TYPE_ROTATION_VECTOR`            | `SensorEvent.values[0]` | 沿 x 轴的旋转矢量分量 (x * sin(θ/2))。           | 无单位   |
|                                   | `SensorEvent.values[1]` | 沿 y 轴的旋转矢量分量 (y * sin(θ/2))。           |          |
|                                   | `SensorEvent.values[2]` | 沿 z 轴的旋转矢量分量 (z * sin(θ/2))。           |          |
|                                   | `SensorEvent.values[3]` | 旋转矢量的标量分量 ((cos(θ/2))。1                |          |
| `TYPE_SIGNIFICANT_MOTION`         | 不适用                  | 不适用                                           | 不适用   |
| `TYPE_STEP_COUNTER`               | `SensorEvent.values[0]` | 已激活传感器最后一次重新启动以来用户迈出的步数。 | 步数     |
| `TYPE_STEP_DETECTOR`              | 不适用                  | 不适用                                           | 不适用   |

**1** 标量分量是一个可选值。



## 使用线性加速度计

线性加速传感器为您提供了一个三维矢量，表示沿着每个设备轴的加速度（不包括重力）。您可以使用此值执行手势检测。该值还可以用作惯性导航系统的输入值，该系统使用航位推测法。以下代码展示如何获取默认线性加速传感器的实例：

```java
private SensorManager sensorManager;
private Sensor sensor;
...
sensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
sensor = sensorManager.getDefaultSensor(Sensor.TYPE_LINEAR_ACCELERATION);
```

从概念上讲，此传感器根据以下关系为您提供加速度数据：

```
linear acceleration = acceleration - acceleration due to gravity
```

当您想获取加速度数据而不受重力影响时，通常会使用此传感器。例如，您可以使用此传感器查看汽车行驶的速度。线性加速度传感器始终具有一个偏移量，您需要将其删除。最简单的方法是在应用中构建一个校准步骤。在校准期间，您可以要求用户将设备放在桌子上，然后读取所有三个轴的偏移量。然后，您可以从加速传感器的直接读数中减去该偏移量，以获得实际的线性加速度。

传感器[坐标系](https://developer.android.google.cn/guide/topics/sensors/sensors_overview#sensors-coords)与加速度传感器使用的坐标系相同，计量单位 (m/s2) 也相同。



## 使用旋转矢量传感器

旋转矢量将设备的屏幕方向表示为角度和轴的组合，其中设备已围绕轴（x、y 或 z）旋转了 θ 度。以下代码展示如何获取默认旋转矢量传感器的实例：

```java
private SensorManager sensorManager;
private Sensor sensor;
...
sensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR);
```

旋转矢量的三个元素表示如下：

![x*sin(θ/2)、y*sin(θ/2)、z*sin(θ/2)](https://developer.android.google.cn/images/guide/topics/sensors/rotational_vec.png)

其中旋转矢量的大小等于 sin(θ/2)，并且旋转矢量的方向等于旋转轴的方向。

![img](https://developer.android.google.cn/images/axis_globe.png)

旋转矢量的三个元素等于单位四元数（cos(θ/2)、x*sin(θ/2)、y*sin(θ/2)、z*sin(θ/2)）的最后三个分量。旋转矢量的元素没有单位。x、y 和 z 轴的定义方法与加速传感器的定义方法相同。参考坐标系被定义为直接正交基础（见图 1）。该坐标系具有以下特征：

- X 定义为矢量积 Y x Z。其在设备当前位置与地面相切，并大约指向东。
- Y 在设备当前位置与地面相切，并指向地磁北极。
- Z 指向天空并与地平面垂直。

有关展示如何使用旋转矢量传感器的示例应用，请参阅 [RotationVectorDemo.java](https://android.googlesource.com/platform/development/+/master/samples/ApiDemos/src/com/example/android/apis/os/RotationVectorDemo.java)。



## 使用有效运动传感器

每次检测到有效运动时，有效运动传感器都会触发事件，然后将其禁用。有效运动是可能导致用户位置发生变化的运动；例如步行、骑自行车或坐在行驶的车上。以下代码展示如何获取默认有效运动传感器的实例以及如何注册事件侦听器：

```java
private SensorManager sensorManager;
private Sensor sensor;
private TriggerEventListener triggerEventListener;
...
sensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
sensor = sensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION);

triggerEventListener = new TriggerEventListener() {
    @Override
    public void onTrigger(TriggerEvent event) {
        // Do work
    }
};

sensorManager.requestTriggerSensor(triggerEventListener, mSensor);
```

如需了解详细信息，请参阅 `TriggerEventListener`。



## 使用计步器传感器

计步器传感器提供自已激活传感器后最后一次重启以来用户迈出的步数。与步测器传感器相比，计步器的延迟时间更长（最多 10 秒），但精确度更高。

**注意：**您必须声明 [`ACTIVITY_RECOGNITION`](https://developer.android.google.cn/reference/android/Manifest.permission#ACTIVITY_RECOGNITION) 权限，以便您的应用在运行 Android 10 (API 级别 29) 或更高版本的设备上使用此传感器。

以下代码展示如何获取默认计步器传感器的实例：

```java
private SensorManager sensorManager;
private Sensor sensor;
...
sensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
sensor = sensorManager.getDefaultSensor(Sensor.TYPE_STEP_COUNTER);
```

如要保护运行应用的设备上的电池，您应使用 `JobScheduler` 类，从而以特定的时间间隔从计步器传感器检索当前值。尽管不同类型的应用需要不同的传感器读取间隔，但是除非您的应用需要来自传感器的实时数据，否则应尽可能延长此间隔。



## 使用步测器传感器

每次用户迈步时，步测器传感器都会触发事件。延迟时间预计将低于 2 秒。

**注意：**您必须声明 [`ACTIVITY_RECOGNITION`](https://developer.android.google.cn/reference/android/Manifest.permission#ACTIVITY_RECOGNITION) 权限，以便您的应用在运行 Android 10 (API 级别 29) 或更高版本的设备上使用此传感器。

以下代码展示如何获取默认步测器传感器的实例：

```java
private SensorManager sensorManager;
private Sensor sensor;
...
sensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
sensor = sensorManager.getDefaultSensor(Sensor.TYPE_STEP_DETECTOR);
```



## 使用原始数据

以下传感器可为您的应用提供有关施加到设备的线性力和旋转力的原始数据。为了有效使用这些传感器的值，您需要从环境中滤除重力等因素。您可能还需要对值趋势应用平滑算法以减少噪声。



### 使用加速度计

加速度传感器测量施加到设备的加速度，包括重力。以下代码展示如何获取默认加速传感器的实例：

```java
private SensorManager sensorManager;
private Sensor sensor;
  ...
sensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
```

从概念上讲，加速度传感器通过使用以下关系测量施加到传感器本身的力 (Fs) 来确定施加到设备的加速度 (Ad)：

![A_D=-(1/mass)∑F_S](https://developer.android.google.cn/images/guide/topics/sensors/acceleration.png)

但是，重力始终根据以下关系影响测量的加速度：

![A_D=-g-(1/mass)∑F_S](https://developer.android.google.cn/images/guide/topics/sensors/acceleration_with_grav.png)

因此，当设备位于桌子上（不加速）时，加速度计的读数为 g = 9.81 m/s2。同样，当设备自由落体并因此以 9.81 m/s2 的速度快速向地面加速时，其加速度计的读数为 g = 0 m/s2。因此，要测量设备的实际加速度，必须从加速度计数据中移除重力的作用。这可以通过应用高通滤波器来实现。相反，您可以使用低通滤波器来隔离重力。以下示例展示如何执行此操作：

```java
public void onSensorChanged(SensorEvent event){
    // In this example, alpha is calculated as t / (t + dT),
    // where t is the low-pass filter's time-constant and
    // dT is the event delivery rate.

    final float alpha = 0.8;

    // Isolate the force of gravity with the low-pass filter.
    gravity[0] = alpha * gravity[0] + (1 - alpha) * event.values[0];
    gravity[1] = alpha * gravity[1] + (1 - alpha) * event.values[1];
    gravity[2] = alpha * gravity[2] + (1 - alpha) * event.values[2];

    // Remove the gravity contribution with the high-pass filter.
    linear_acceleration[0] = event.values[0] - gravity[0];
    linear_acceleration[1] = event.values[1] - gravity[1];
    linear_acceleration[2] = event.values[2] - gravity[2];
}
```

**注意：**您可以使用许多不同的技术来过滤传感器数据。以上代码示例使用简单的过滤器常数 (alpha) 来创建低通滤波器。此过滤器常数来自于一个时间常数 (t)，该常数大致表示过滤器添加到传感器事件的延迟时间，以及传感器的事件传输率 (dt)。该代码示例使用 0.8 的 alpha 值进行演示。如果您使用此过滤方法，则可能需要选择其他 alpha 值。

加速度计使用标准的传感器[坐标系](https://developer.android.google.cn/guide/topics/sensors/sensors_overview#sensors-coords)。实际上，这意味着当设备以自然屏幕方向平放在桌子上时，以下条件适用：

- 如果将设备推向左侧（因此向右移动），则 x 加速度值为正。
- 如果将设备推到底部（因此它向远离您的方向移动），则 y 加速度值为正。
- 如果您以 A m/s2 的加速度将设备推向天空，则 z 加速度值等于 A + 9.81，该值对应设备的加速度 (+A m/s2) 减去重力 (-9.81 m/s2)。
- 固定设备的加速度值为 +9.81，该值对应设备的加速度（0 m/s2 减去重力 -9.81 m/s2)。

通常，如果要监控设备的运动，加速度计是一个很好的传感器。几乎所有运行 Android 的手机和平板电脑都具有加速度计，其功耗比其他运动传感器低约 10 倍。一个缺点是您可能必须实现低通和高通滤波器，以消除重力并降低噪声。

Android SDK 提供一个示例应用，展示如何使用加速传感器 ([Accelerometer Play](https://github.com/googlesamples/android-AccelerometerPlay/))。



### 使用陀螺仪

陀螺仪测量围绕设备的 x、y 和 z 轴的旋转速率（弧度/秒）。以下代码展示如何获取默认陀螺仪的实例：



```java
private SensorManager sensorManager;
private Sensor sensor;
...
sensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
sensor = sensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE);
```

传感器的[坐标系](https://developer.android.google.cn/guide/topics/sensors/sensors_overview#sensors-coords)与用于加速传感器的坐标系相同。逆时针方向旋转为正；也就是说，如果观察者从 x、y 或 z 轴上某个正位置看向位于原点的设备，则在该设备看起来是逆时针旋转的情况下，该观察者将报告正旋转。这是正向旋转的标准数学定义，与方向传感器使用的侧倾定义不同。

通常，陀螺仪的输出会随时间积分，以计算描述角度随时间步长变化的旋转。例如：

```java
// Create a constant to convert nanoseconds to seconds.
private static final float NS2S = 1.0f / 1000000000.0f;
private final float[] deltaRotationVector = new float[4]();
private float timestamp;

public void onSensorChanged(SensorEvent event) {
    // This timestep's delta rotation to be multiplied by the current rotation
    // after computing it from the gyro sample data.
    if (timestamp != 0) {
      final float dT = (event.timestamp - timestamp) * NS2S;
      // Axis of the rotation sample, not normalized yet.
      float axisX = event.values[0];
      float axisY = event.values[1];
      float axisZ = event.values[2];

      // Calculate the angular speed of the sample
      float omegaMagnitude = sqrt(axisX*axisX + axisY*axisY + axisZ*axisZ);

      // Normalize the rotation vector if it's big enough to get the axis
      // (that is, EPSILON should represent your maximum allowable margin of error)
      if (omegaMagnitude > EPSILON) {
        axisX /= omegaMagnitude;
        axisY /= omegaMagnitude;
        axisZ /= omegaMagnitude;
      }

      // Integrate around this axis with the angular speed by the timestep
      // in order to get a delta rotation from this sample over the timestep
      // We will convert this axis-angle representation of the delta rotation
      // into a quaternion before turning it into the rotation matrix.
      float thetaOverTwo = omegaMagnitude * dT / 2.0f;
      float sinThetaOverTwo = sin(thetaOverTwo);
      float cosThetaOverTwo = cos(thetaOverTwo);
      deltaRotationVector[0] = sinThetaOverTwo * axisX;
      deltaRotationVector[1] = sinThetaOverTwo * axisY;
      deltaRotationVector[2] = sinThetaOverTwo * axisZ;
      deltaRotationVector[3] = cosThetaOverTwo;
    }
    timestamp = event.timestamp;
    float[] deltaRotationMatrix = new float[9];
    SensorManager.getRotationMatrixFromVector(deltaRotationMatrix, deltaRotationVector);
    // User code should concatenate the delta rotation we computed with the current rotation
    // in order to get the updated rotation.
    // rotationCurrent = rotationCurrent * deltaRotationMatrix;
}
```

标准陀螺仪可提供原始旋转数据，而无需对噪声和漂移（偏差）进行任何过滤或校正。实际上，陀螺仪的噪声和漂移会引入需要补偿的误差。通常，您可以通过监控其他传感器（例如重力传感器或加速度计）来确定漂移（偏差）和噪声。

#### 使用未经校准的陀螺仪

未经校准的陀螺仪与[陀螺仪](https://developer.android.google.cn/guide/topics/sensors/sensors_motion#sensors-motion-gyro)类似，不同之处在于没有陀螺漂移补偿应用于旋转速率。出厂校准和温度补偿仍应用于旋转速率。未经校准的陀螺仪可用于后期处理和融合屏幕方向数据。通常，`gyroscope_event.values[0]` 将接近 `uncalibrated_gyroscope_event.values[0] - uncalibrated_gyroscope_event.values[3]`。即，

```
calibrated_x ~= uncalibrated_x - bias_estimate_x
```