# 概览

### 简介

我们通过利用传感器框架，可以访问多种类型的传感器。这些传感器之中，有些是基于硬件，有些是基于软件。其中基于硬件的大家都很容易理解，基于软件的则并不是物理设备，而是模仿基于硬件的传感器。这些基于软件的传感器会从一个或多个硬件来获取数据，有时候我们也将他们称为虚拟传感器或是合成传感器。

很少有 Android 设备拥有所有类型的传感器。例如，大多数手机设备和平板电脑都有加速度计和磁力计，但很少有气压计或温度计。此外，一个设备可以有多个特定类型的传感器。例如，一个设备可以有两个重力传感器，分别具有不同的量程。

通过下面的表格我们可以知道Android平台所支持的传感器类型

![image-20200410123609113](C:\Users\sumi\AppData\Roaming\Typora\typora-user-images\image-20200410123609113.png)



### 传感器框架

我们可以利用Android传感器框架通过访问我们需要的传感器并获取传感器的原始数据。传感器框架是android.hardware软件包的一部分，它包含了与传感器使用相关的类和接口。



首先我们需要明确，这些相关的API用来做什么。

它的基本任务其实有两个。

1.识别传感器和传感器特性

2.监控传感器事件

听上去是不是并不复杂？

对，它真的不太复杂。



接下来就让我们来看一看这些类和接口吧！

#### SensorManager

这个类是用来创建传感器服务的实例的。该类提供了各种方法来访问和列出传感器，注册和取消注册传感器事件监听器，以及获取屏幕方向信息。它还提供了几个传感器常量，用于报告传感器精确度，设置数据采集频率和校准传感器。

#### Sensor

这个类用来创建特定传感器的实例。该类提供了各种方法来确定传感器的特性。

#### SensorEvent

系统使用这个类来创建传感器事件对象，该对象提供有关传感器事件的信息。传感器事件对象中包含以下信息：原始传感器数据、生成事件的传感器类型、数据的准确度和事件的时间戳。

#### SensorEventListener

可以使用此接口创建两种回调方法，以在传感器值或传感器精确度发生变化时接收传感器事件。



这些就是我们在安卓传感器使用过程中最基本的一些API，但我们需要知道，传感器的可用性不仅仅取决于我们的手机上是否有我们需要的传感器，还取决于Android的版本。

事实上随着安卓版本的更新，部分传感器正在逐步被更加好的传感器所取代，但是被弃用的传感器事实上其实仍是可以在后续平台上使用。

下面我们简单列举一下传感器在不同平台上的可用性。

![image-20200410203955394](C:\Users\sumi\AppData\Roaming\Typora\typora-user-images\image-20200410203955394.png)



### 识别传感器和传感器特性

很多人可能会有这样的疑问：

我咋知道我手机上有什么传感器？

或许有人会说：试试呗，试试不就知道了。

虽然说传感器并没有多到试不完的程度，但是一个一个试你可能确实会过一会儿就累死了。

幸运的是，我们有能够获取手机上传感器的方法。

伟大的Android传感器框架给我们提供了几个能够在运行的时候轻松确定设备上有哪些传感器的方法，以及每个传感器的特性，例如最大量程、分辨率和功率要求。

下面我们来看一看具体的实现。

我们可以将过程分为几个步骤。

1.获得对传感器服务的引用

```
    private SensorManager sensorManager;
    ...
    sensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
    
```

2.调用 `getSensorList()` 方法并使用 `TYPE_ALL` 常量来获取设备上每种传感器的列表

```
    List<Sensor> deviceSensors = sensorManager.getSensorList(Sensor.TYPE_ALL);
    
```

如果您想列出特定类型的所有传感器，可以使用其他常量来代替 `TYPE_ALL`，例如 `TYPE_GYROSCOPE`、`TYPE_LINEAR_ACCELERATION` 或 `TYPE_GRAVITY`。



此外，我们也可以使用 `getDefaultSensor()` 方法并传入特定传感器的类型常量，来确定设备上是否存在相关类型的传感器。

这个在官方开发者文档上有详细的示例，就不多赘述了。



### 监控传感器事件

接下来要说的是监听接口。

首先我们先要明确：我们在什么情况下需要调用这个接口呢？

下面我们列出两种情况：

1.传感器的准确度发生了变化

在这种情况下，系统会调用 `onAccuracyChanged()` 方法，提供对于发生变化的 `Sensor` 对象的引用以及传感器的新准确度。

准确度由以下 4 个状态常量之一表示：`SENSOR_STATUS_ACCURACY_LOW`、`SENSOR_STATUS_ACCURACY_MEDIUM`、`SENSOR_STATUS_ACCURACY_HIGH` 或 `SENSOR_STATUS_UNRELIABLE`。

2.传感器报告了新的值

在这种情况下，系统会调用 `onSensorChanged()` 方法，提供 `SensorEvent` 对象。`SensorEvent` 对象包含关于新传感器数据的信息，包括：数据的准确度、生成数据的传感器、生成数据的时间戳以及传感器记录的新数据。

下面给出一个开发者文档上摘录的使用 `onSensorChanged()` 方法监控光传感器的数据的例子。

在本示例中，原始传感器数据作为 `sensor_data` 显示在 main.xml 文件中定义的 `TextView` 中。

```
    public class SensorActivity extends Activity implements SensorEventListener {
        private SensorManager sensorManager;
        private Sensor mLight;

        @Override
        public final void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.main);

            sensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
            mLight = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT);
        }

        @Override
        public final void onAccuracyChanged(Sensor sensor, int accuracy) {
            // Do something here if sensor accuracy changes.
        }

        @Override
        public final void onSensorChanged(SensorEvent event) {
            // The light sensor returns a single value.
            // Many sensors return 3 values, one for each axis.
            float lux = event.values[0];
            // Do something with this sensor value.
        }

        @Override
        protected void onResume() {
            super.onResume();
            sensorManager.registerListener(this, mLight, SensorManager.SENSOR_DELAY_NORMAL);
        }

        @Override
        protected void onPause() {
            super.onPause();
            sensorManager.unregisterListener(this);
        }
    }
    
```

在本示例中，在调用 `registerListener()` 方法时指定了默认数据延迟 (`SENSOR_DELAY_NORMAL`)。数据延迟（或采样率）控制传感器事件通过 `onSensorChanged()` 回调方法发送到应用的时间间隔。默认数据延迟采用 200,000 微秒的延迟，适用于监控典型的屏幕方向变化。您可以指定其他数据延迟，比如 `SENSOR_DELAY_GAME`（延迟 20,000 微秒）、`SENSOR_DELAY_UI`（延迟 60,000 微秒），或 `SENSOR_DELAY_FASTEST`（延迟 0 微秒）。从 Android 3.0（API 级别 11）开始，还可以将延迟指定为以微秒为单位的绝对值。



### 传感器坐标系

说了这么多传感器，但事实上我们对于传感器使用的坐标系还一无所知，这里我们就拿出来讲一讲。

通常，传感器框架使用标准的 3 轴坐标系来表示数据值。对于大多数传感器，当设备处于默认屏幕方向时，会相对于设备屏幕来定义坐标系（参见图 1）。当设备处于默认屏幕方向时，X 轴为水平向右延伸，Y 轴为垂直向上延伸，Z 轴为垂直于屏幕向外延伸。在此坐标系中，屏幕后面的坐标将具有负 Z 值。

![img](https://developer.android.google.cn/images/axis_device.png)

**图 1.** Sensor API 使用的坐标系（相对于设备）。



在通用的一些传感器中，以下传感器使用此坐标系：

- 加速度传感器
- 重力传感器
- 陀螺仪
- 线性加速度传感器
- 地磁场传感器



关于此坐标系，特别需要注意的一点就是当设备的屏幕方向改变时，坐标轴不会转换，也就是说，传感器的坐标系不会随着设备的移动而改变。此行为与我们之前学习过的 OpenGL 坐标系的行为是相同的。

还需要注意的一点是，您的应用不能假设设备的自然（默认）屏幕方向是竖屏。许多平板设备的自然屏幕方向为横屏。传感器坐标系始终基于设备的自然屏幕方向。

最后，如果您的应用将传感器数据对应到屏幕显示，您需要使用 `getRotation()` 方法确定屏幕的旋转度，然后使用 `remapCoordinateSystem()` 方法将传感器坐标映射到屏幕坐标。即使您的清单指定了仅限竖屏显示，您也需要这样做。

**注意**：有些传感器和方法使用的坐标系基于世界参照系（而不是设备参照系）。这些传感器和方法返回的数据表示设备相对于地球的运动或位置。如需了解详情，我们可以去查看`getOrientation()` 方法、`getRotationMatrix()`方法、屏幕方向传感器和旋转矢量传感器。

